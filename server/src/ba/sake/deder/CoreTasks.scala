package ba.sake.deder

import java.io.File
import scala.jdk.CollectionConverters.*
import scala.util.Using
import com.typesafe.scalalogging.StrictLogging
import ba.sake.tupson.JsonRW
import ba.sake.deder.zinc.{DederZincLogger, JdkUtils, ZincCompilersCache}
import ba.sake.deder.config.DederProject.{
  JavaModule,
  ModuleType,
  ScalaJsModule,
  ScalaModule,
  ScalaNativeModule,
  ScalaTestModule
}
import ba.sake.deder.deps.Dependency
import ba.sake.deder.deps.DependencyResolver
import ba.sake.deder.deps.given
import ba.sake.deder.jar.{JarManifest, JarUtils}
import ba.sake.deder.scalajs.ScalaJsLinker
import ba.sake.deder.scalanative.ScalaNativeLinker
import ba.sake.deder.testing.*
import dependency.ScalaVersion

class CoreTasks() extends StrictLogging {

  /** source folders */
  val sourcesTask = SourceFilesTask(
    name = "sources",
    execute = { ctx =>
      val sources = ctx.module match {
        case m: JavaModule => m.sources.asScala.toSeq
        case _             => Seq.empty
      }
      sources.map(s => DederPath(os.SubPath(s"${ctx.module.root}/${s}")))
    },
    description = "Source folders of the module"
  )

  // sources generated by annotation processors
  val generatedSourcesTask = TaskBuilder
    .make[os.Path](
      name = "generatedSources"
    )
    .build { ctx => ctx.out }

  /** resource folders */
  val resourcesTask = SourceFilesTask(
    name = "resources",
    execute = { ctx =>
      val resources = ctx.module match {
        case m: JavaModule => m.resources.asScala.toSeq
        case _             => Seq.empty
      }
      resources.map(s => DederPath(os.SubPath(s"${ctx.module.root}/${s}")))
    }
  )

  val javaHomeTask = ConfigValueTask[Option[os.Path]](
    name = "javaHome",
    execute = { ctx =>
      ctx.module match {
        case m: JavaModule => Option(m.javaHome).map(p => os.Path(p))
        case _             => None
      }
    }
  )

  val javaVersionTask = ConfigValueTask[Option[String]](
    name = "javaVersion",
    execute = { ctx =>
      ctx.module match {
        case m: JavaModule => Option(m.javaVersion)
        case _             => None
      }
    }
  )

  val javacOptionsTask = ConfigValueTask[Seq[String]](
    name = "javacOptions",
    execute = { ctx =>
      ctx.module match {
        case m: JavaModule => m.javacOptions.asScala.toSeq
        case _             => Seq.empty
      }
    }
  )

  val scalacOptionsTask = ConfigValueTask[Seq[String]](
    name = "scalacOptions",
    execute = { ctx =>
      ctx.module match {
        case m: ScalaModule => m.scalacOptions.asScala.toSeq
        case _              => Seq.empty
      }
    }
  )

  val scalaVersionTask = ConfigValueTask[String](
    name = "scalaVersion",
    execute = { ctx =>
      ctx.module match {
        case m: ScalaModule => m.scalaVersion
        case _              => "2.13.17" // dummy default scala version
      }
    }
  )

  val depsTask = ConfigValueTask[Seq[String]](
    name = "deps",
    execute = { ctx =>
      ctx.module match {
        case m: JavaModule => m.deps.asScala.toSeq
        case _             => Seq.empty
      }
    }
  )

  // applied deps, with scala version resolved
  val dependenciesTask = TaskBuilder
    .make[Seq[deps.Dependency]](
      name = "dependencies"
    )
    .dependsOn(depsTask)
    .dependsOn(scalaVersionTask)
    .build { ctx =>
      val (deps, scalaVersion) = ctx.depResults
      val platformSuffix = ctx.module match {
        case m: ScalaJsModule     => ScalaVersion.jsBinary(m.scalaJSVersion).map("sjs" + _)
        case m: ScalaNativeModule => ScalaVersion.nativeBinary(m.scalaNativeVersion).map("native" + _)
        case _                    => None
      }
      deps.map(depDecl => Dependency.make(depDecl, scalaVersion, platformSuffix))
    }

  val allDependenciesTask = TaskBuilder
    .make[Seq[deps.Dependency]](
      name = "allDependencies",
      transitive = true
    )
    .dependsOn(dependenciesTask)
    .build { ctx =>
      val deps = ctx.depResults._1
      (deps ++ ctx.transitiveResults.flatten.flatten).distinct
    }

  val classesTask = TaskBuilder
    .make[os.Path](
      name = "classes"
    )
    .build { ctx => ctx.out }

  val semanticdbDirTask = TaskBuilder
    .make[os.Path](
      name = "semanticdb"
    )
    .build { ctx => ctx.out }

  // this is localRunClasspath in mill ??
  val allClassesDirsTask = TaskBuilder
    .make[Seq[os.Path]](
      name = "allClassesDirs",
      transitive = true
    )
    .dependsOn(classesTask)
    .build { ctx =>
      Seq(ctx.depResults._1) ++ ctx.transitiveResults.flatten.flatten
    }

  val compileClasspathTask = TaskBuilder
    .make[Seq[os.Path]](
      name = "compileClasspath",
      transitive = true
    )
    .dependsOn(scalaVersionTask)
    .dependsOn(allDependenciesTask)
    .dependsOn(allClassesDirsTask)
    .build { ctx =>
      // we feed even this module's classes dir because of javac annotation processing,
      // it can generate java sources.. and then scala sources can depend on them
      val (scalaVersion, dependencies, allClassesDirs) = ctx.depResults
      val scalaLibDeps =
        if scalaVersion.startsWith("3.") then
          ctx.module match {
            case m: ScalaJsModule =>
              Seq(
                Dependency.make(
                  s"org.scala-lang::scala3-library::${scalaVersion}",
                  scalaVersion,
                  ScalaVersion.jsBinary(m.scalaJSVersion).map("sjs" + _)
                ),
                Dependency.make(s"org.scala-js::scalajs-library:${m.scalaJSVersion}", "2.13")
              )
            case m: ScalaNativeModule =>
              val scalaSpecificVersion = s"${scalaVersion}+${m.scalaNativeVersion}"
              Seq(
                Dependency.make(s"org.scala-lang::scala3-library:${scalaVersion}", scalaVersion),
                Dependency.make(
                  s"org.scala-native::scala3lib::${scalaSpecificVersion}",
                  scalaVersion,
                  ScalaVersion.nativeBinary(m.scalaNativeVersion).map("native" + _)
                ),
                Dependency.make(
                  s"org.scala-native::scalalib::${scalaSpecificVersion}",
                  scalaVersion,
                  ScalaVersion.nativeBinary(m.scalaNativeVersion).map("native" + _)
                ),
                Dependency.make(
                  s"org.scala-native::javalib::${m.scalaNativeVersion}",
                  scalaVersion,
                  ScalaVersion.nativeBinary(m.scalaNativeVersion).map("native" + _)
                ),
                Dependency.make(
                  s"org.scala-native::nativelib::${m.scalaNativeVersion}",
                  scalaVersion,
                  ScalaVersion.nativeBinary(m.scalaNativeVersion).map("native" + _)
                ),
                Dependency.make(
                  s"org.scala-native::auxlib::${m.scalaNativeVersion}",
                  scalaVersion,
                  ScalaVersion.nativeBinary(m.scalaNativeVersion).map("native" + _)
                ),
                Dependency.make(
                  s"org.scala-native::clib::${m.scalaNativeVersion}",
                  scalaVersion,
                  ScalaVersion.nativeBinary(m.scalaNativeVersion).map("native" + _)
                ),
                Dependency.make(
                  s"org.scala-native::posixlib::${m.scalaNativeVersion}",
                  scalaVersion,
                  ScalaVersion.nativeBinary(m.scalaNativeVersion).map("native" + _)
                )
              )
            case m: ScalaModule => Seq(Dependency.make(s"org.scala-lang::scala3-library:${scalaVersion}", scalaVersion))
            case _              => Seq.empty
          }
        else
          ctx.module match {
            case m: ScalaJsModule =>
              Seq(
                Dependency.make(
                  s"org.scala-lang:scala-library:${scalaVersion}",
                  scalaVersion,
                  ScalaVersion.jsBinary(m.scalaJSVersion).map("sjs" + _)
                ),
                Dependency.make(s"org.scala-js::scalajs-library:${m.scalaJSVersion}", "2.13")
              )
            case m: ScalaNativeModule =>
              val scalaSpecificVersion = s"${scalaVersion}+${m.scalaNativeVersion}"
              Seq(
                Dependency.make(s"org.scala-lang:scala-library:${scalaVersion}", scalaVersion),
                Dependency.make(
                  s"org.scala-native::scalalib::${scalaSpecificVersion}",
                  scalaVersion,
                  ScalaVersion.nativeBinary(m.scalaNativeVersion).map("native" + _)
                ),
                Dependency.make(
                  s"org.scala-native::javalib::${m.scalaNativeVersion}",
                  scalaVersion,
                  ScalaVersion.nativeBinary(m.scalaNativeVersion).map("native" + _)
                ),
                Dependency.make(
                  s"org.scala-native::nativelib::${m.scalaNativeVersion}",
                  scalaVersion,
                  ScalaVersion.nativeBinary(m.scalaNativeVersion).map("native" + _)
                ),
                Dependency.make(
                  s"org.scala-native::auxlib::${m.scalaNativeVersion}",
                  scalaVersion,
                  ScalaVersion.nativeBinary(m.scalaNativeVersion).map("native" + _)
                ),
                Dependency.make(
                  s"org.scala-native::clib::${m.scalaNativeVersion}",
                  scalaVersion,
                  ScalaVersion.nativeBinary(m.scalaNativeVersion).map("native" + _)
                ),
                Dependency.make(
                  s"org.scala-native::posixlib::${m.scalaNativeVersion}",
                  scalaVersion,
                  ScalaVersion.nativeBinary(m.scalaNativeVersion).map("native" + _)
                )
              )
            case m: ScalaModule => Seq(Dependency.make(s"org.scala-lang:scala-library:${scalaVersion}", scalaVersion))
            case _              => Seq.empty
          }
      val depsJars = DependencyResolver
        .fetchFiles(scalaLibDeps ++ dependencies, Some(ctx.notifications))
      // val additionalCompileClasspath = ctx.transitiveResults.flatten.flatten ++ depsJars
      (allClassesDirs ++ depsJars).reverse.distinct.reverse
    }

  val semanticdbEnabledTask = ConfigValueTask[Boolean](
    name = "semanticdbEnabled",
    execute = { ctx =>
      ctx.module match {
        case m: JavaModule => m.semanticdbEnabled
        case _             => false
      }
    }
  )

  val javaSemanticdbVersionTask = ConfigValueTask[String](
    name = "javaSemanticdbVersion",
    execute = { ctx =>
      ctx.module match {
        case m: JavaModule => m.javaSemanticdbVersion
        case _             => "0.11.1"
      }
    }
  )

  val scalaSemanticdbVersionTask = TaskBuilder
    .make[String](
      name = "scalaSemanticdbVersion",
      transitive = true
    )
    .dependsOn(scalaVersionTask)
    .build { ctx =>
      val scalaVersion = ctx.depResults._1
      ctx.module match {
        case m: ScalaModule =>
          Option(m.scalaSemanticdbVersion).getOrElse {
            scalaVersion match {
              case s"2.13.${minor}" =>
                val minorNum = minor.toInt
                if minorNum == 1 then "4.6.0"
                else if minorNum < 8 then "4.8.4"
                else if minorNum == 8 then "4.8.9"
                else if minorNum == 9 then "4.9.0"
                else if minorNum == 10 then "4.9.3"
                else if minorNum == 11 then "4.9.9"
                else if minorNum == 12 then "4.12.3"
                else if minorNum == 13 then "4.13.9"
                else if minorNum == 14 then "4.14.1"
                else "4.14.5"
              case _ => "4.14.5"
            }
          }
        case _ => "4.14.5"
      }
    }

  val javacAnnotationProcessorDepsTask = ConfigValueTask[Seq[String]](
    name = "javacAnnotationProcessorDeps",
    execute = { ctx =>
      ctx.module match {
        case m: JavaModule => m.javacAnnotationProcessorDeps.asScala.toSeq
        case _             => Seq.empty
      }
    }
  )

  val javacAnnotationProcessorsTask = TaskBuilder
    .make[Seq[os.Path]](
      name = "javacAnnotationProcessors"
    )
    .dependsOn(scalaVersionTask)
    .dependsOn(semanticdbEnabledTask)
    .dependsOn(javaSemanticdbVersionTask)
    .dependsOn(javacAnnotationProcessorDepsTask)
    .build { ctx =>
      val (scalaVersion, semanticdbEnabled, javaSemanticdbVersion, javacAnnotationProcessorDeps) = ctx.depResults
      val allDeps = javacAnnotationProcessorDeps ++
        Option.when(semanticdbEnabled)(s"com.sourcegraph:semanticdb-javac:${javaSemanticdbVersion}")
      val processorJars = DependencyResolver.fetchFiles(
        allDeps.map(d => Dependency.make(d, scalaVersion)),
        Some(ctx.notifications)
      )
      processorJars
    }

  val scalacPluginDepsTask = ConfigValueTask[Seq[String]](
    name = "scalacPluginDeps",
    execute = { ctx =>
      ctx.module match {
        case m: ScalaModule => m.scalacPluginDeps.asScala.toSeq
        case _              => Seq.empty
      }
    }
  )

  val scalacPluginsTask = TaskBuilder
    .make[Seq[os.Path]](
      name = "scalacPlugins"
    )
    .dependsOn(scalaVersionTask)
    .dependsOn(semanticdbEnabledTask)
    .dependsOn(scalaSemanticdbVersionTask)
    .dependsOn(scalacPluginDepsTask)
    .build { ctx =>
      val (scalaVersion, semanticdbEnabled, scalaSemanticdbVersion, scalacPluginDeps) = ctx.depResults
      val semanticDbDeps =
        if scalaVersion.startsWith("3.") then Seq.empty
        else Option.when(semanticdbEnabled)(s"org.scalameta:::semanticdb-scalac:${scalaSemanticdbVersion}").toSeq
      val scalaJsDeps =
        if scalaVersion.startsWith("3.") then
          ctx.module match {
            case m: ScalaNativeModule => Seq(s"org.scala-native:::nscplugin:${m.scalaNativeVersion}")
            case _                    => Seq.empty
          }
        else
          ctx.module match {
            case m: ScalaJsModule     => Seq(s"org.scala-js:::scalajs-compiler:${m.scalaJSVersion}")
            case m: ScalaNativeModule => Seq(s"org.scala-native:::nscplugin:${m.scalaNativeVersion}")
            case _                    => Seq.empty
          }
      val allDeps = scalacPluginDeps ++ semanticDbDeps ++ scalaJsDeps
      val pluginJars = DependencyResolver.fetchFiles(
        allDeps.map(d => Dependency.make(d, scalaVersion)), // .exclude(dependency.Module("*", "*"))),
        Some(ctx.notifications)
      )
      pluginJars
    }

  val compileTask = TaskBuilder
    .make[DederPath](
      name = "compile",
      transitive = true
    )
    .dependsOn(sourcesTask)
    .dependsOn(generatedSourcesTask)
    .dependsOn(javaHomeTask)
    .dependsOn(javaVersionTask)
    .dependsOn(javacOptionsTask)
    .dependsOn(scalacOptionsTask)
    .dependsOn(scalaVersionTask)
    .dependsOn(compileClasspathTask)
    .dependsOn(classesTask)
    .dependsOn(semanticdbDirTask)
    .dependsOn(scalacPluginsTask)
    .dependsOn(javacAnnotationProcessorsTask)
    .dependsOn(semanticdbEnabledTask)
    .build { ctx =>
      val (
        sourceDirs,
        generatedSourcesDir,
        javaHome,
        javaVersion,
        javacOptions,
        scalacOptions,
        scalaVersion,
        compileClasspath,
        classesDir,
        semanticdbDir,
        scalacPlugins,
        javacAnnotationProcessors,
        semanticdbEnabled
      ) = ctx.depResults

      JdkUtils.checkCompat(JdkUtils.getVersion(scala.util.Properties.javaSpecVersion), scalaVersion)

      val sourceFiles = sourceDirs
        .map(_.absPath)
        .flatMap { sourceDir =>
          if os.exists(sourceDir) then
            os.walk(
              sourceDir,
              skip = p => {
                if os.isDir(p) then false
                else if os.isFile(p) then !(p.ext == "scala" || p.ext == "java")
                else true
              }
            )
          else Seq.empty
        }
        .filter(os.isFile)

      // annotation processors need generated sources dir to exist
      os.makeDir.all(generatedSourcesDir)

      // TODO scalajs compiler on scala2
      val compilerDeps =
        if scalaVersion.startsWith("3.") then
          ctx.module match {
            case m: ScalaJsModule =>
              Seq(
                Dependency.make(
                  s"org.scala-lang::scala3-compiler:${scalaVersion}",
                  scalaVersion,
                  ScalaVersion.jsBinary(m.scalaJSVersion).map("sjs" + _)
                )
              )
            case m: ScalaModule =>
              Seq(Dependency.make(s"org.scala-lang::scala3-compiler:${scalaVersion}", scalaVersion))
            case _ => Seq.empty
          }
        else
          ctx.module match {
            case m: ScalaModule =>
              Seq(
                Dependency.make(s"org.scala-lang:scala-compiler:${scalaVersion}", scalaVersion),
                Dependency.make(s"org.scala-lang:scala-reflect:${scalaVersion}", scalaVersion)
              )
            case _ => Seq.empty
          }
      val compilerJars = DependencyResolver.fetchFiles(
        compilerDeps // .map(d => Dependency.make(d, scalaVersion))
      )

      val zincCacheFile = ctx.out / "inc_compile.zip"
      val zincLogger = new DederZincLogger(ctx.notifications, ctx.module.id)

      val finalJavacOptions = javacOptions ++
        Option
          .when(javacAnnotationProcessors.nonEmpty)(
            Seq(
              "-s",
              generatedSourcesDir.toString,
              "-processorpath",
              javacAnnotationProcessors.map(_.toString).mkString(File.pathSeparator)
            )
          )
          .toSeq
          .flatten ++
        javaVersion.map(v => Seq("--release", v)).getOrElse(Seq.empty) ++
        Option.when(semanticdbEnabled)(
          // https://github.com/sourcegraph/scip-java/issues/390
          s"-Xplugin:semanticdb -sourceroot:${DederGlobals.projectRootDir} -targetroot:${semanticdbDir} -build-tool:sbt"
        )

      val semanticDbScalacOpts =
        if semanticdbEnabled then
          if scalaVersion.startsWith("3.") then
            Seq(
              "-Xsemanticdb",
              "-sourceroot",
              DederGlobals.projectRootDir.toString,
              "-semanticdb-target",
              semanticdbDir.toString
            )
          else
            Seq(
              "-Yrangepos",
              s"-P:semanticdb:sourceroot:${DederGlobals.projectRootDir}",
              s"-P:semanticdb:targetroot:${semanticdbDir}"
            )
        else Seq.empty
      val platformSpecificScalacOptions = ctx.module match {
        case module: ScalaJsModule => if scalaVersion.startsWith("3.") then Seq("-scalajs") else Seq.empty
        case _                     => Seq.empty
      }
      val finalScalacOptions =
        scalacOptions ++ scalacPlugins
          .map(p => s"-Xplugin:${p.toString}") ++ platformSpecificScalacOptions ++ semanticDbScalacOpts

      ZincCompilersCache
        .get(scalaVersion)
        .compile(
          javaHome = javaHome.map(_.toNIO),
          scalaVersion = scalaVersion,
          compilerJars = compilerJars,
          compileClasspath = compileClasspath,
          zincCacheFile = zincCacheFile,
          sources = sourceFiles,
          classesDir = classesDir,
          scalacOptions = finalScalacOptions,
          javacOptions = finalJavacOptions,
          zincLogger = zincLogger,
          moduleId = ctx.module.id,
          notifications = ctx.notifications
        )
      DederPath(classesDir)
    }

  val jvmOptionsTask = ConfigValueTask[Seq[String]](
    name = "jvmOptions",
    execute = { ctx =>
      ctx.module match {
        case m: JavaModule => m.jvmOptions.asScala.toSeq
        case _             => Seq.empty
      }
    }
  )

  val runClasspathTask = TaskBuilder
    .make[Seq[os.Path]](
      name = "runClasspath",
      transitive = true
    )
    .dependsOn(scalaVersionTask)
    .dependsOn(allDependenciesTask)
    .dependsOn(compileTask)
    .dependsOn(resourcesTask)
    .build { ctx =>
      val (scalaVersion, dependencies, classesDir, resourceDirs) = ctx.depResults
      val mandatoryDeps = ctx.module match {
        case _: ScalaModule =>
          val scalaLibDep =
            if scalaVersion.startsWith("3.") then s"org.scala-lang::scala3-library:${scalaVersion}"
            else s"org.scala-lang:scala-library:${scalaVersion}"
          Seq(Dependency.make(scalaLibDep, scalaVersion))
        case _ => Seq.empty
      }
      val depsJars = DependencyResolver.fetchFiles(mandatoryDeps ++ dependencies, Some(ctx.notifications))

      // classdirs that are last in each module are pushed last in final classpath
      val classesDirsAbs = Seq(classesDir).map(_.absPath)
      val resources = resourceDirs.map(_.absPath)
      (classesDirsAbs ++ resources ++ ctx.transitiveResults.flatten.flatten ++ depsJars).reverse.distinct.reverse
    }

  val mainClassesTask = TaskBuilder
    .make[Seq[String]](
      name = "mainClasses"
    )
    .dependsOn(compileTask)
    .dependsOn(classesTask)
    .build { ctx =>
      val (_, classesDir) = ctx.depResults
      MainClassesDiscovery.discover(Seq(classesDir))
    }

  val mainClassTask = ConfigValueTask[Option[String]](
    name = "mainClass",
    execute = { ctx =>
      ctx.module match {
        case m: JavaModule => Option(m.mainClass)
        case _             => None
      }
    }
  )

  val finalMainClassTask = TaskBuilder
    .make[Option[String]](
      name = "finalMainClass"
    )
    .dependsOn(mainClassTask)
    .dependsOn(mainClassesTask)
    .build { ctx =>
      val (mainClass, discoveredMainClasses) = ctx.depResults
      mainClass
        .orElse {
          Option.when(discoveredMainClasses.length == 1)(discoveredMainClasses.head)
        }
    }

  val runTask = TaskBuilder
    .make[Seq[String]](
      name = "run",
      singleton = true
    )
    .dependsOn(runClasspathTask)
    .dependsOn(finalMainClassTask)
    .dependsOn(jvmOptionsTask)
    .build { ctx =>
      val (runClasspath, mainClass, jvmOptions) = ctx.depResults
      mainClass match {
        case Some(mc) =>
          val cp = runClasspath.map(_.toString)
          val cmd = Seq("java") ++ jvmOptions ++ Seq("-cp", cp.mkString(File.pathSeparator), mc) ++ ctx.args
          logger.debug(s"Client should run command: ${cmd}")
          ctx.notifications.add(ServerNotification.RunSubprocess(cmd, ctx.watch))
          // TODO run ScalaJS with node
          cmd
        case None =>
          // TODO ability to set one..
          throw new Exception(s"No main class specified for module: ${ctx.module.id}")
      }
    }

  val testClassesTask = TaskBuilder
    .make[Seq[DiscoveredFrameworkTests]](
      name = "testClasses",
      supportedModuleTypes = Set(ModuleType.SCALA_TEST)
    )
    .dependsOn(classesTask)
    .dependsOn(runClasspathTask)
    .build { ctx =>
      val (classesDir, runClasspath) = ctx.depResults
      val runtimeClasspath = (Seq(classesDir) ++ runClasspath).reverse.distinct.reverse
      ClassLoaderUtils.withClassLoader(runtimeClasspath) { classLoader =>
        val frameworkClassNames = ctx.module.asInstanceOf[ScalaTestModule].testFrameworks.asScala.toSeq
        val testDiscovery = DederTestDiscovery(
          classLoader = classLoader,
          testClassesDir = classesDir,
          testClasspath = runtimeClasspath,
          frameworkClassNames = frameworkClassNames,
          logger = DederTestLogger(ctx.notifications, ctx.module.id)
        )
        testDiscovery.discover().map { case (framework, tests) =>
          DiscoveredFrameworkTests(framework.name(), tests.map(_._1))
        }
      }
    }

  val testTask = TaskBuilder
    .make[DederTestResults](
      name = "test",
      supportedModuleTypes = Set(ModuleType.SCALA_TEST)
    )
    .dependsOn(classesTask)
    .dependsOn(runClasspathTask)
    // cant reuse testClassesTask coz Framework is not Json-able...
    .build { ctx =>
      val (classesDir, runClasspath) = ctx.depResults
      val runtimeClasspath = (Seq(classesDir) ++ runClasspath).reverse.distinct.reverse
      ClassLoaderUtils.withClassLoader(runtimeClasspath) { classLoader =>
        val frameworkClassNames = ctx.module.asInstanceOf[ScalaTestModule].testFrameworks.asScala.toSeq
        val logger = DederTestLogger(ctx.notifications, ctx.module.id)
        val testDiscovery = DederTestDiscovery(
          classLoader = classLoader,
          testClassesDir = classesDir,
          testClasspath = runtimeClasspath,
          frameworkClassNames = frameworkClassNames,
          logger = logger
        )
        val frameworkTests = testDiscovery.discover()
        Using.resource(java.util.concurrent.Executors.newFixedThreadPool(DederGlobals.testWorkerThreads)) {
          executorService =>
            val testRunner = DederTestRunner(executorService, frameworkTests, classLoader, logger)
            val testOptions = DederTestOptions(ctx.args)
            testRunner.run(testOptions)
        }
      }
    }

  // TODO manifest config
  val jarTask = TaskBuilder
    .make[os.Path](name = "jar")
    .dependsOn(compileTask)
    .dependsOn(finalMainClassTask)
    .build { ctx =>
      val (localClasspath, mainClass) = ctx.depResults
      val resultJarPath = ctx.out / s"${ctx.module.id}.jar"
      val jarInputPaths = Seq(localClasspath.absPath)
      val manifest = mainClass match {
        case Some(mc) =>
          JarManifest.Default.add(java.util.jar.Attributes.Name.MAIN_CLASS.toString -> mc)
        case None => JarManifest.Default
      }
      JarUtils.createJar(
        resultJarPath,
        jarInputPaths,
        manifest
      )
      resultJarPath
    }

  val allJarsTask = TaskBuilder
    .make[Seq[os.Path]](
      name = "allJars",
      transitive = true
    )
    .dependsOn(jarTask)
    .build { ctx =>
      val jar = ctx.depResults._1
      ctx.transitiveResults.flatten.flatten.prepended(jar).reverse.distinct.reverse
    }

  val assemblyTask = TaskBuilder
    .make[os.Path](
      name = "assembly",
      supportedModuleTypes = Set(ModuleType.JAVA, ModuleType.SCALA, ModuleType.SCALA_TEST)
    )
    .dependsOn(scalaVersionTask)
    .dependsOn(finalMainClassTask)
    .dependsOn(allDependenciesTask)
    .dependsOn(allJarsTask)
    .build { ctx =>
      val (scalaVersion, mainClass, dependencies, allModulesJars) = ctx.depResults
      // TODO mandatoryDeps task..
      val mandatoryDeps = ctx.module match {
        case _: ScalaModule =>
          val scalaLibDep =
            if scalaVersion.startsWith("3.") then s"org.scala-lang::scala3-library:${scalaVersion}"
            else s"org.scala-lang:scala-library:${scalaVersion}"
          Seq(Dependency.make(scalaLibDep, scalaVersion))
        case _ => Seq.empty
      }
      val depsJars = DependencyResolver.fetchFiles(mandatoryDeps ++ dependencies, Some(ctx.notifications))
      val tmpDir = ctx.out / "jars"
      os.makeDir.all(tmpDir)
      allModulesJars.zipWithIndex.foreach { case (jar, index) =>
        val jarName = s"${index + 1}-${jar.last}"
        os.copy.over(jar, tmpDir / jarName)
      }
      val allJars = os.list(tmpDir) ++ depsJars
      val manifest = mainClass match {
        case Some(mc) =>
          JarManifest.Default.add(java.util.jar.Attributes.Name.MAIN_CLASS.toString -> mc)
        case None => JarManifest.Default
      }
      val mergedJar = ctx.out / "mergedJar.jar"
      JarUtils.mergeJars(mergedJar, allJars, manifest)
      val resultJarPath = ctx.out / "out.jar"
      JarUtils.createAssemblyJar(resultJarPath, mergedJar)
      resultJarPath
    }

  val fastLinkJsTask = TaskBuilder
    .make[String](
      name = "fastLinkJs",
      supportedModuleTypes = Set(ModuleType.SCALA_JS)
    )
    // TODO runtimeClasspath?
    .dependsOn(compileClasspathTask)
    .dependsOn(finalMainClassTask)
    .build { ctx =>
      val (compileClasspath, mainClass) = ctx.depResults
      val irContainers = compileClasspath
      os.makeDir.all(ctx.out)
      import scala.concurrent.ExecutionContext.Implicits.global
      val linker = new ScalaJsLinker(ctx.notifications, ctx.module.id)
      linker.link(
        irContainers = irContainers,
        outputDir = ctx.out,
        mainClass = mainClass,
        jsModuleKind = ctx.module.asInstanceOf[ScalaJsModule].moduleKind
      )
      // TODO thread pool..
      ""
    }

  val nativeLinkTask = TaskBuilder
    .make[String](
      name = "nativeLink",
      supportedModuleTypes = Set(ModuleType.SCALA_NATIVE)
    )
    .dependsOn(compileClasspathTask)
    .dependsOn(finalMainClassTask)
    .build { ctx =>
      val (compileClasspath, mainClass) = ctx.depResults
      val nirPaths = compileClasspath
      os.makeDir.all(ctx.out)
      import scala.concurrent.ExecutionContext.Implicits.global
      val linker = new ScalaNativeLinker(ctx.notifications, ctx.module.id)
      linker.link(
        nirPaths = nirPaths,
        outputDir = ctx.out,
        mainClass = mainClass,
        nativeLibs = Seq.empty
      )
      // TODO thread pool..
      ""
    }

  // order matters for dependency resolution!!
  val all: Seq[Task[?, ?]] = Seq(
    sourcesTask,
    generatedSourcesTask,
    javaHomeTask,
    javaVersionTask,
    scalaVersionTask,
    resourcesTask,
    javacOptionsTask,
    scalacOptionsTask,
    semanticdbEnabledTask,
    javaSemanticdbVersionTask,
    scalaSemanticdbVersionTask,
    javacAnnotationProcessorDepsTask,
    scalacPluginDepsTask,
    javacAnnotationProcessorsTask,
    scalacPluginsTask,
    depsTask,
    dependenciesTask,
    allDependenciesTask,
    classesTask,
    semanticdbDirTask,
    allClassesDirsTask,
    compileClasspathTask,
    compileTask,
    jvmOptionsTask,
    runClasspathTask,
    mainClassTask,
    mainClassesTask,
    finalMainClassTask,
    runTask,
    testClassesTask,
    testTask,
    jarTask,
    allJarsTask,
    assemblyTask,
    fastLinkJsTask,
    nativeLinkTask
  )

  private val allNames = all.map(_.name)
  private val distinctNames = allNames.distinct
  private val diff = allNames.diff(distinctNames)
  require(diff.isEmpty, s"Duplicate task names: ${diff.mkString(", ")}")
}
